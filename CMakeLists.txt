project(idevice-rs-test)
cmake_minimum_required(VERSION 3.10)

set(CMAKE_CXX_STANDARD 20)

if (APPLE) 
    set(CMAKE_OSX_DEPLOYMENT_TARGET "14.0")
endif()

include_directories(include)
find_package(PkgConfig REQUIRED)

find_program(CARGO_EXECUTABLE cargo REQUIRED)
message(STATUS "Using idevice-rs Rust implementation")

set(IDEVICE_RS_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/idevice-rs)
set(IDEVICE_RS_LIB_PATH ${IDEVICE_RS_SOURCE_DIR}/target/release/libidevice_ffi.a)

# This command builds the Rust library and declares its output file.
# Any target that uses this output file will automatically depend on this command.
add_custom_command(
    OUTPUT ${IDEVICE_RS_LIB_PATH}
    COMMAND ${CMAKE_COMMAND} -E env MACOSX_DEPLOYMENT_TARGET=14.0 ${CARGO_EXECUTABLE} build --release --manifest-path ${IDEVICE_RS_SOURCE_DIR}/Cargo.toml
    WORKING_DIRECTORY ${IDEVICE_RS_SOURCE_DIR}
    COMMENT "Building idevice-rs FFI library"
    VERBATIM
)

# This custom target provides a name to build the Rust library explicitly.
# It depends on the output file, ensuring the custom command is run.
add_custom_target(idevice_rs_build DEPENDS ${IDEVICE_RS_LIB_PATH})

# Create an imported target for the Rust static library
add_library(idevice_ffi STATIC IMPORTED GLOBAL)
set_target_properties(idevice_ffi PROPERTIES
    IMPORTED_LOCATION "${IDEVICE_RS_LIB_PATH}"
)

# ---- Build the idevice-rs C++ wrapper library ------------------------------
set(IDEVICE_CPP_SRC_DIR     ${IDEVICE_RS_SOURCE_DIR}/cpp/src)
set(IDEVICE_CPP_INCLUDE_DIR ${IDEVICE_RS_SOURCE_DIR}/cpp/include)
set(IDEVICE_FFI_INCLUDE_DIR ${IDEVICE_RS_SOURCE_DIR}/ffi)
set(PLIST_CPP_INCLUDE_DIR   ${IDEVICE_RS_SOURCE_DIR}/plist_ffi/cpp/include)
set(PLIST_CPP_SRC_DIR       ${IDEVICE_RS_SOURCE_DIR}/plist_ffi/cpp/src)

# Collect C++ sources for the wrapper library
file(GLOB_RECURSE IDEVICE_CPP_SOURCES
  "${IDEVICE_CPP_SRC_DIR}/*.cpp"
)
file(GLOB PLIST_CPP_SOURCES
  "${PLIST_CPP_SRC_DIR}/*.cpp"
)

add_library(idevice_cpp STATIC ${IDEVICE_CPP_SOURCES} ${PLIST_CPP_SOURCES})

target_include_directories(idevice_cpp PUBLIC
    ${IDEVICE_CPP_INCLUDE_DIR}
    ${PLIST_CPP_INCLUDE_DIR}
  PRIVATE
    ${IDEVICE_FFI_INCLUDE_DIR}
)

# Link idevice_cpp to idevice_ffi and add platform-specific dependencies
find_package(Threads REQUIRED)
target_link_libraries(idevice_cpp PUBLIC idevice_ffi Threads::Threads)

if (UNIX AND NOT APPLE)
    pkg_check_modules(UDEV REQUIRED IMPORTED_TARGET udev)
    target_link_libraries(idevice_cpp PUBLIC PkgConfig::UDEV dl m)
elseif(APPLE)
    find_library(COREFOUNDATION_FRAMEWORK CoreFoundation REQUIRED)
    find_library(IOKIT_FRAMEWORK IOKit REQUIRED)
    target_link_libraries(idevice_cpp PUBLIC
        ${COREFOUNDATION_FRAMEWORK}
        ${IOKIT_FRAMEWORK}
        "-framework Security"
        "-framework SystemConfiguration"
        "-framework CoreServices"
        "-framework CFNetwork"
    )
elseif(WIN32)
    target_link_libraries(idevice_cpp PUBLIC ws2_32 userenv.lib ntdll bcrypt)
endif()

# Set up variables for linking and includes for the main iDescriptor target
set(IDEVICE_IMPLEMENTATION_LIBS idevice_cpp)
# The C header file generated by cbindgen lives here
set(IDEVICE_IMPLEMENTATION_INCLUDES ${IDEVICE_RS_SOURCE_DIR}/ffi/include)
add_dependencies(idevice_cpp idevice_rs_build)


add_executable(idevice-rs-test main.cpp)
target_link_libraries(idevice-rs-test PRIVATE idevice_cpp)
